\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage{titlesec}

\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\rhead{Guide Me Backend Documentation}
\lfoot{Page \thepage}

% Code styling
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\title{\Huge\textbf{Guide Me Backend Documentation} \\ \Large Comprehensive Technical Reference}
\author{Backend Architecture Documentation}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\section{Executive Summary}

Guide Me is a sophisticated Django-based artificial intelligence mentoring platform that provides personalized learning experiences through advanced conversational AI, document analysis, diagram generation, and multimedia content integration. The backend architecture implements a robust, scalable system designed to handle real-time AI interactions, user preference management, and multi-modal content delivery.

\subsection{Core Platform Capabilities}

The platform delivers four primary service categories:
\begin{itemize}
    \item \textbf{Intelligent Conversational AI}: Real-time streaming responses with context-aware interactions
    \item \textbf{Document Intelligence}: RAG (Retrieval Augmented Generation) for processing and querying uploaded documents
    \item \textbf{Visual Learning Tools}: Automated diagram generation and interactive quiz creation
    \item \textbf{Multimedia Integration}: YouTube content recommendations and flashcard generation
\end{itemize}

\section{System Architecture Overview}

\subsection{Technology Stack}

The Guide Me backend leverages a modern Python-based technology stack:

\begin{itemize}
    \item \textbf{Framework}: Django 5.x with Django REST Framework
    \item \textbf{Database}: PostgreSQL with UUID primary keys
    \item \textbf{AI Integration}: Groq API for LLM interactions, Google Gemini for specialized tasks
    \item \textbf{Authentication}: Django Allauth with JWT token support
    \item \textbf{File Handling}: Django's file storage system with binary field support
    \item \textbf{Async Support}: ASGI compatibility for real-time streaming
\end{itemize}

\subsection{Application Structure}

The project follows Django's modular architecture with three primary applications:

\begin{enumerate}
    \item \textbf{chatgpt/}: Main project configuration and URL routing
    \item \textbf{users/}: User management, authentication, and preference system
    \item \textbf{chat/}: Core AI interaction, messaging, and content generation
\end{enumerate}

\section{User Management System}

\subsection{Authentication Architecture}

The user management system implements a comprehensive authentication solution supporting multiple registration methods and detailed user profiling.

\subsubsection{User Model Design}

\begin{lstlisting}[language=Python, caption=CustomUser Model Implementation]
class CustomUser(AbstractUser):
    email = models.EmailField(unique=True)
    profile_image = models.ImageField(upload_to='profile_images/', blank=True, null=True)
    
    # Learning style preferences
    learning_style_visual = models.BooleanField(default=False)
    learning_style_auditory = models.BooleanField(default=False)
    learning_style_kinesthetic = models.BooleanField(default=False)
    learning_style_reading = models.BooleanField(default=False)
    
    # Study preferences
    preferred_study_time = models.CharField(max_length=10, choices=STUDY_TIME_CHOICES, default='medium')
    quiz_preference = models.IntegerField(choices=QUIZ_PREFERENCE_CHOICES, default=3)
    
    # Interest management through intermediate model
    interests = models.ManyToManyField(Interest, through="UserInterest", related_name="users", blank=True)
\end{lstlisting}

\subsubsection{Registration and Onboarding Flow}

The registration system supports both traditional email/password registration and Google OAuth integration:

\textbf{UserRegistrationView}: Handles traditional registration with comprehensive preference collection during signup. The view processes learning style preferences, study time preferences, quiz preferences, and user interests in a single atomic transaction.

\begin{lstlisting}[language=Python, caption=Registration Flow Implementation]
def post(self, request):
    form = CustomUserCreationForm(request.POST, request.FILES)
    if form.is_valid():
        with transaction.atomic():
            user = form.save(commit=False)
            
            # Process learning style preferences
            learning_styles = {
                'visual': request.POST.get('learning_style_visual') == "1",
                'auditory': request.POST.get('learning_style_auditory') == "1",
                'kinesthetic': request.POST.get('learning_style_kinesthetic') == "1",
                'reading': request.POST.get('learning_style_reading') == "1",
            }
            for style, value in learning_styles.items():
                setattr(user, f'learning_style_{style}', value)
            
            user.save()
            
            # Process interests
            interest_names = request.POST.getlist('interests')
            for interest_name in interest_names:
                interest, created = Interest.objects.get_or_create(name=interest_name)
                UserInterest.objects.create(user=user, interest=interest)
\end{lstlisting}

\textbf{GoogleSignupPreferencesView}: Specialized view for users who register via Google OAuth, allowing them to set preferences post-authentication.

\subsection{User Profile Management}

The \textbf{UserProfileView} provides comprehensive profile management capabilities:

\begin{itemize}
    \item Profile information updates (email, profile image)
    \item Learning preference modifications
    \item Interest management (add/remove interests)
    \item Password change functionality
    \item Bulk interest operations
\end{itemize}

\subsubsection{Interest Management System}

The platform implements a sophisticated interest management system using a many-to-many relationship with an intermediate model:

\begin{lstlisting}[language=Python, caption=Interest Management Models]
class Interest(models.Model):
    name = models.CharField(max_length=100, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

class UserInterest(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    interest = models.ForeignKey(Interest, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ('user', 'interest')
\end{lstlisting}

\subsection{Authentication Endpoints}

\begin{itemize}
    \item \texttt{POST /users/register/}: User registration with preference collection
    \item \texttt{GET/POST /users/login/}: Standard Django authentication
    \item \texttt{GET/POST /users/profile/}: Profile management and updates
    \item \texttt{POST /users/register-preferences/}: Google OAuth preference setup
    \item \texttt{POST /users/token/}: JWT token generation
    \item \texttt{POST /users/token/refresh/}: JWT token refresh
\end{itemize}

\section{Chat System Architecture}

\subsection{Core Chat Models}

The chat system is built around four primary models that handle different aspects of conversational AI:

\begin{lstlisting}[language=Python, caption=Chat System Models]
class Chat(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='chats')
    title = models.CharField(max_length=100, default="New Chat")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

class Message(models.Model):
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='messages')
    role = models.CharField(max_length=10, choices=[('user', 'User'), ('assistant', 'Assistant')])
    content = models.TextField(blank=True)
    type = models.CharField(max_length=20, default='text', 
                          choices=[('text', 'Text'), ('quiz', 'Quiz'), ('diagram', 'Diagram'), ('youtube', 'YouTube')])
    structured_content = models.JSONField(null=True, blank=True)
    quiz_html = models.TextField(blank=True, null=True)
    diagram_image = models.ForeignKey(DiagramImage, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    is_edited = models.BooleanField(default=False)
    edited_at = models.DateTimeField(null=True, blank=True)
\end{lstlisting}

\subsection{Real-Time Streaming Architecture}

\subsubsection{ChatView Implementation}

The \textbf{ChatView} serves as the primary interface for chat interactions, handling both GET requests for chat display and providing AJAX support for message updates:

\begin{lstlisting}[language=Python, caption=ChatView Core Logic]
@method_decorator(login_required, name='dispatch')
class ChatView(View):
    def get(self, request, chat_id=None):
        # Handle AJAX requests for message updates
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' and chat_id:
            try:
                chat = Chat.objects.get(id=chat_id, user=request.user)
                messages = list(chat.messages.all().order_by('created_at').values('role', 'content'))
                return JsonResponse({'messages': messages})
            except Chat.DoesNotExist:
                return JsonResponse({'error': 'Chat not found'}, status=404)
\end{lstlisting}

\subsubsection{Streaming Response System}

The \textbf{ChatStreamView} implements sophisticated real-time streaming using Django's StreamingHttpResponse:

\begin{lstlisting}[language=Python, caption=Streaming Implementation Core]
class ChatStreamView(View):
    async def stream_response(self, chat, messages_for_llm, **kwargs):
        async def event_stream_async():
            try:
                accumulated_response = ""
                stream = await chat_service.stream_completion(
                    messages=messages_for_llm, 
                    query=query_for_rag,
                    files_rag=files_rag_instance,
                    max_tokens=max_tokens_for_llm,
                    chat_id=chat.id
                )
                
                frontend_buffer = ""
                BUFFER_LENGTH_THRESHOLD_CHARS = 50
                
                for chunk in stream:
                    content = getattr(chunk.choices[0].delta, "content", None)
                    if content:
                        accumulated_response += content
                        frontend_buffer += content
                        
                        if ("\n" in frontend_buffer) or (len(frontend_buffer) >= BUFFER_LENGTH_THRESHOLD_CHARS):
                            yield f"data: {json.dumps({'type': 'content', 'content': frontend_buffer})}\n\n"
                            frontend_buffer = ""
\end{lstlisting}

\subsection{Multi-Modal Message Processing}

The chat system supports multiple message types through a unified processing pipeline:

\begin{enumerate}
    \item \textbf{Text Messages}: Standard conversational AI responses
    \item \textbf{Quiz Messages}: Interactive HTML-based quizzes stored in \texttt{quiz\_html} field
    \item \textbf{Diagram Messages}: Generated diagrams with binary storage and URL serving
    \item \textbf{YouTube Messages}: Structured content with video recommendations
\end{enumerate}

\subsection{Chat Management Endpoints}

\begin{itemize}
    \item \texttt{GET /chat/new/}: Create new chat interface
    \item \texttt{GET /chat/<uuid>/}: Display existing chat with message history
    \item \texttt{POST /chat/create/}: Initialize new chat with first message
    \item \texttt{POST /chat/<uuid>/stream/}: Real-time streaming message processing
    \item \texttt{POST /chat/<uuid>/delete/}: Delete chat and associated messages
    \item \texttt{POST /chat/<uuid>/update-title/}: Update chat title
    \item \texttt{POST /chat/<uuid>/clear/}: Clear all messages from chat
    \item \texttt{POST /chat/<uuid>/message/<int>/edit/}: Edit user messages with conversation reset
\end{itemize}

\section{AI Integration Features}

\subsection{RAG (Retrieval Augmented Generation) System}

\subsubsection{Document Processing Architecture}

The RAG system enables users to upload documents and query them within chat conversations:

\begin{lstlisting}[language=Python, caption=RAG File Model]
class ChatRAGFile(models.Model):
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='rag_files')
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    file = models.FileField(upload_to=rag_file_upload_path)
    original_filename = models.CharField(max_length=255)
    uploaded_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = [['chat', 'original_filename']]
\end{lstlisting}

\subsubsection{RAG File Management}

The \textbf{ChatRAGFilesView} provides comprehensive file management:

\begin{lstlisting}[language=Python, caption=RAG File Operations]
class ChatRAGFilesView(View):
    def post(self, request, chat_id):
        MAX_RAG_FILES = 10
        chat = get_object_or_404(Chat, id=chat_id, user=request.user)
        
        if chat.rag_files.count() >= MAX_RAG_FILES:
            return JsonResponse({'error': f'RAG file limit ({MAX_RAG_FILES}) reached.'}, status=400)
        
        uploaded_file = request.FILES.get('file')
        allowed_extensions = ['.pdf', '.txt']
        file_name, file_extension = os.path.splitext(uploaded_file.name)
        
        if file_extension.lower() not in allowed_extensions:
            return JsonResponse({'error': 'Invalid file type. Only PDF and TXT are allowed.'}, status=400)
\end{lstlisting}

\subsection{Diagram Generation System}

\subsubsection{Diagram Storage Model}

\begin{lstlisting}[language=Python, caption=Diagram Storage Implementation]
class DiagramImage(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='diagram_images')
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='diagram_images')
    image_data = models.BinaryField()
    filename = models.CharField(max_length=255, default="diagram.png")
    content_type = models.CharField(max_length=50, default="image/png")
    created_at = models.DateTimeField(auto_now_add=True)
\end{lstlisting}

\subsubsection{Diagram Generation Flow}

The diagram generation process integrates seamlessly with the chat streaming system:

\begin{lstlisting}[language=Python, caption=Diagram Generation in Stream]
if diagram_mode_active:
    diagram_topic_query = current_user_prompt_for_saving if current_user_prompt_for_saving else messages_for_llm[-1]['content']
    
    diagram_image_record_id = await chat_service.generate_diagram_image(
        chat_history_messages=messages_for_llm[:-1], 
        user_query=diagram_topic_query, 
        chat_id=chat.id,
        user_id=user_id_for_diagram
    )
    
    if diagram_image_record_id:
        diagram_message_content = f"Diagram for: {diagram_topic_query[:100]}"
        
        new_diagram_message = await sync_to_async(Message.objects.create)(
            chat=chat, 
            role='assistant', 
            content=diagram_message_content,
            type='diagram',
            diagram_image_id=diagram_image_record_id
        )
\end{lstlisting}

\subsection{Quiz Generation System}

\subsubsection{Quiz Creation Endpoint}

The quiz generation system analyzes conversation history to create relevant assessments:

\begin{lstlisting}[language=Python, caption=Quiz Generation Logic]
@login_required
@require_POST
def chat_quiz(request, chat_id):
    chat = get_object_or_404(Chat, id=chat_id, user=request.user)
    messages = chat.messages.filter(role__in=['user', 'assistant']).order_by('created_at')
    content_text = "\n".join(m.content for m in messages if m.content)
    
    user_messages_count = messages.filter(role='user').count()
    assistant_messages_count = messages.filter(role='assistant').count()
    
    if user_messages_count < 2 or assistant_messages_count < 1 or len(content_text) < 200:
        return JsonResponse({'error': 'Not enough diverse conversation content'}, status=400)
    
    prompt = f"""Create at least 2 multiple-choice quizzes based on the conversation...
    [HTML structure specification]
    Conversation: {content_text}"""
    
    quiz_html_response = async_to_sync(chat_service.get_completion)(
        messages=[{"role": "user", "content": prompt}],
        max_tokens=1500,
        chat_id=chat.id
    )
\end{lstlisting}

\subsection{YouTube Integration System}

The YouTube integration provides curated video recommendations based on user queries:

\begin{lstlisting}[language=Python, caption=YouTube Integration Flow]
if youtube_mode_active:
    agent_response = await chat_service.get_youtube_agent_response(query_for_youtube_agent)
    
    try:
        video_data = json.loads(agent_response)
        if isinstance(video_data, list):
            await sync_to_async(Message.objects.create)(
                chat=chat, 
                role='assistant', 
                content="Here are some videos I found for you:",
                type='youtube',
                structured_content=video_data
            )
            yield f"data: {json.dumps({'type': 'youtube_recommendations', 'data': video_data})}\n\n"
    except (json.JSONDecodeError, ValueError):
        await sync_to_async(Message.objects.create)(chat=chat, role='assistant', content=agent_response)
\end{lstlisting}

\subsection{Flashcard Generation}

\subsubsection{Flashcard Generation Endpoint}

\begin{lstlisting}[language=Python, caption=Flashcard Generation System]
@csrf_exempt
def generate_flashcards_view(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        topic = data.get('topic', '').strip()
        
        prompt = f"""Generate a list of flashcards for the topic of "{topic}". 
        Each flashcard should have a term and a concise definition. 
        Format: Term: Definition"""
        
        response = flashcard_model.generate_content(prompt)
        text = response.text.strip()
        
        flashcards = []
        for line in text.splitlines():
            if ":" in line:
                parts = line.split(":", 1)
                term = parts[0].strip()
                definition = parts[1].strip() if len(parts) > 1 else ""
                if term and definition:
                    flashcards.append({"term": term, "definition": definition})
        
        return JsonResponse({"flashcards": flashcards})
\end{lstlisting}

\section{Advanced Features Implementation}

\subsection{Message Editing System}

The platform supports comprehensive message editing with conversation history management:

\begin{lstlisting}[language=Python, caption=Message Editing Implementation]
@login_required
@require_POST
def edit_message(request, chat_id, message_id):
    chat = get_object_or_404(Chat, id=chat_id, user=request.user)
    message_to_edit = get_object_or_404(Message, id=message_id, chat=chat)
    
    if message_to_edit.role != 'user':
        return JsonResponse({'error': 'Only user messages can be edited.'}, status=403)
    
    data = json.loads(request.body)
    new_content = data.get('new_content', '').strip()
    
    message_to_edit.content = new_content
    message_to_edit.is_edited = True
    message_to_edit.edited_at = timezone.now()
    message_to_edit.save()
    
    # Delete all messages that came after the edited message
    Message.objects.filter(chat=chat, created_at__gt=message_to_edit.created_at).delete()
\end{lstlisting}

\subsection{File Upload and Processing}

The system handles multiple file upload scenarios with intelligent text extraction:

\begin{lstlisting}[language=Python, caption=File Processing Logic]
async def post(self, request, chat_id):
    uploaded_file = request.FILES.get('file')
    file_info_for_llm = None
    
    if uploaded_file:
        file_info_for_llm = chat_service.extract_text_from_uploaded_file(uploaded_file)
        llm_query_content = (
            f"{user_typed_prompt}\n\n"
            f"[Content from uploaded file '{file_info_for_llm['filename']}':]\n"
            f"{file_info_for_llm['text_content']}\n"
        )
        
        if file_info_for_llm['was_truncated']:
            warning_msg = f"The content was truncated (from {file_info_for_llm['original_char_count']} to {file_info_for_llm['final_char_count']} characters)"
\end{lstlisting}

\subsection{Error Handling and Resilience}

The system implements comprehensive error handling across all major operations:

\begin{lstlisting}[language=Python, caption=Error Handling Implementation]
try:
    stream = await chat_service.stream_completion(messages=messages_for_llm)
    # Process stream...
except APIStatusError as e:
    logger.error(f"Groq APIStatusError: Status {e.status_code}")
    user_message = "An API error occurred with the language model."
    if e.status_code == 413:
        user_message = "The request is too large for the model. Please try reducing your message size."
    yield f"data: {json.dumps({'type': 'error', 'content': user_message})}\n\n"
except Exception as e:
    logger.error(f"Generic exception: {str(e)}", exc_info=True)
    yield f"data: {json.dumps({'type': 'error', 'content': 'An unexpected error occurred.'})}\n\n"
\end{lstlisting}

\section{URL Routing and API Structure}

\subsection{Main Project URLs}

\begin{lstlisting}[language=Python, caption=Main URL Configuration]
# chatgpt/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', ChatView.as_view(), name='chat'),
    path('chat/', include('chat.urls')),
    path('users/', include('users.urls')),
    path('accounts/', include('allauth.urls')),
    path('api/', include('rest_framework.urls')),
]
\end{lstlisting}

\subsection{Chat Application URLs}

\begin{lstlisting}[language=Python, caption=Chat URL Patterns]
# chat/urls.py
urlpatterns = [
    path('new/', ChatView.as_view(), name='new_chat'),
    path('create/', views.create_chat, name='create_chat'),
    path('<uuid:chat_id>/', ChatView.as_view(), name='chat_detail'),
    path('<uuid:chat_id>/stream/', ChatStreamView.as_view(), name='chat_stream'),
    path('<uuid:chat_id>/delete/', views.delete_chat, name='delete_chat'),
    path('<uuid:chat_id>/update-title/', views.update_chat_title, name='update_chat_title'),
    path('<uuid:chat_id>/clear/', views.clear_chat, name='clear_chat'),
    path('<uuid:chat_id>/quiz/', chat_quiz, name='chat_quiz'),
    path('<uuid:chat_id>/rag-files/', views.ChatRAGFilesView.as_view(), name='list_rag_files'),
    path('<uuid:chat_id>/rag-files/<int:file_id>/delete/', views.ChatRAGFilesView.as_view(), name='delete_rag_file'),
    path('<uuid:chat_id>/message/<int:message_id>/edit/', views.edit_message, name='edit_message'),
    path('flashcards/', generate_flashcards_view, name='flashcards_generator'),
    path('diagram_image/<uuid:diagram_id>/', serve_diagram_image, name='serve_diagram_image'),
]
\end{lstlisting}

\subsection{User Management URLs}

\begin{lstlisting}[language=Python, caption=User URL Patterns]
# users/urls.py
urlpatterns = [
    path('login/', LoginView.as_view(template_name='users/login.html'), name='login'),
    path('register/', UserRegistrationView.as_view(), name='register'),
    path('register-preferences/', GoogleSignupPreferencesView.as_view(), name='google_preferences'),
    path('profile/', UserProfileView.as_view(), name='profile'),
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('settings/', UserProfileView.as_view(), name='settings'),
]
\end{lstlisting}

\section{Database Design and Schema Architecture}

\subsection{Database Overview and Technology Stack}

The Guide Me platform utilizes PostgreSQL as the primary database management system, leveraging Django's ORM for database abstraction and management. The schema design emphasizes scalability, data integrity, and performance optimization through strategic use of UUIDs, proper indexing, and normalized relationships.

\subsection{Entity Relationship Diagram}

The database architecture consists of seven core entities with well-defined relationships that support the platform's AI-driven educational features.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/erd_overview.png}
    \caption{Guide Me Database Entity Relationship Diagram - Complete Overview}
    \label{fig:erd_overview}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{images/erd_detailed.png}
    \caption{Detailed ERD showing all attributes and constraints}
    \label{fig:erd_detailed}
\end{figure}

\subsection{Core Entity Relationships}

The database design implements the following primary relationships:

\begin{itemize}
    \item \textbf{CustomUser} $\leftrightarrow$ \textbf{Chat}: One-to-Many (User can have multiple chats)
    \item \textbf{Chat} $\leftrightarrow$ \textbf{Message}: One-to-Many (Chat contains multiple messages)
    \item \textbf{Chat} $\leftrightarrow$ \textbf{DiagramImage}: One-to-Many (Chat can have multiple diagrams)
    \item \textbf{Chat} $\leftrightarrow$ \textbf{ChatRAGFile}: One-to-Many (Chat can have multiple RAG files)
    \item \textbf{CustomUser} $\leftrightarrow$ \textbf{Interest}: Many-to-Many through UserInterest
    \item \textbf{Message} $\leftrightarrow$ \textbf{DiagramImage}: One-to-One optional (Message may reference diagram)
    \item \textbf{CustomUser} $\leftrightarrow$ \textbf{DiagramImage}: One-to-Many (User owns multiple diagrams)
    \item \textbf{CustomUser} $\leftrightarrow$ \textbf{ChatRAGFile}: One-to-Many (User uploads multiple RAG files)
\end{itemize}

\subsection{Detailed Schema Documentation}

\subsubsection{CustomUser Table Schema}

The \texttt{users\_customuser} table extends Django's AbstractUser with educational platform-specific fields:

\begin{lstlisting}[language=SQL, caption=CustomUser Table Structure]
CREATE TABLE users_customuser (
    id SERIAL PRIMARY KEY,
    password VARCHAR(128) NOT NULL,
    last_login TIMESTAMP WITH TIME ZONE,
    is_superuser BOOLEAN NOT NULL,
    username VARCHAR(150) UNIQUE NOT NULL,
    first_name VARCHAR(150) NOT NULL,
    last_name VARCHAR(150) NOT NULL,
    email VARCHAR(254) UNIQUE NOT NULL,
    is_staff BOOLEAN NOT NULL,
    is_active BOOLEAN NOT NULL,
    date_joined TIMESTAMP WITH TIME ZONE NOT NULL,
    profile_image VARCHAR(100),
    
    -- Learning Style Preferences
    learning_style_visual BOOLEAN NOT NULL DEFAULT FALSE,
    learning_style_auditory BOOLEAN NOT NULL DEFAULT FALSE,
    learning_style_kinesthetic BOOLEAN NOT NULL DEFAULT FALSE,
    learning_style_reading BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Study Preferences
    study_habits TEXT NOT NULL,
    preferred_study_time VARCHAR(10) NOT NULL DEFAULT 'medium',
    quiz_preference INTEGER NOT NULL DEFAULT 3,
    
    -- Constraints
    CONSTRAINT users_customuser_quiz_preference_check 
        CHECK (quiz_preference >= 1 AND quiz_preference <= 5),
    CONSTRAINT users_customuser_preferred_study_time_check 
        CHECK (preferred_study_time IN ('short', 'medium', 'long'))
);

-- Indexes
CREATE INDEX users_customuser_email_idx ON users_customuser(email);
CREATE INDEX users_customuser_username_idx ON users_customuser(username);
\end{lstlisting}

\subsubsection{Interest and UserInterest Tables Schema}

The interest management system implements a many-to-many relationship through an intermediate table:

\begin{lstlisting}[language=SQL, caption=Interest Management Tables]
CREATE TABLE users_interest (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE users_userinterest (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    interest_id INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- Foreign Key Constraints
    CONSTRAINT users_userinterest_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users_customuser(id) ON DELETE CASCADE,
    CONSTRAINT users_userinterest_interest_id_fkey 
        FOREIGN KEY (interest_id) REFERENCES users_interest(id) ON DELETE CASCADE,
    
    -- Unique Constraint
    CONSTRAINT users_userinterest_unique_user_interest 
        UNIQUE (user_id, interest_id)
);

-- Indexes
CREATE INDEX users_interest_name_idx ON users_interest(name);
CREATE INDEX users_userinterest_user_id_idx ON users_userinterest(user_id);
CREATE INDEX users_userinterest_interest_id_idx ON users_userinterest(interest_id);
CREATE INDEX users_userinterest_created_at_idx ON users_userinterest(created_at DESC);
\end{lstlisting}

\subsubsection{Chat Table Schema}

The chat table uses UUID primary keys for better scalability and security:

\begin{lstlisting}[language=SQL, caption=Chat Table Structure]
CREATE TABLE chat_chat (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL,
    title VARCHAR(100) NOT NULL DEFAULT 'New Chat',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- Foreign Key Constraints
    CONSTRAINT chat_chat_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users_customuser(id) ON DELETE CASCADE
);

-- Indexes
CREATE INDEX chat_chat_user_id_idx ON chat_chat(user_id);
CREATE INDEX chat_chat_updated_at_idx ON chat_chat(updated_at);
CREATE INDEX chat_chat_created_at_idx ON chat_chat(created_at);

-- Trigger for auto-updating updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_chat_updated_at 
    BEFORE UPDATE ON chat_chat 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
\end{lstlisting}

\subsubsection{Message Table Schema}

The message table supports multiple content types through polymorphic design:

\begin{lstlisting}[language=SQL, caption=Message Table Structure]
CREATE TABLE chat_message (
    id SERIAL PRIMARY KEY,
    chat_id UUID NOT NULL,
    role VARCHAR(10) NOT NULL,
    content TEXT NOT NULL DEFAULT '',
    type VARCHAR(20) NOT NULL DEFAULT 'text',
    structured_content JSONB,
    quiz_html TEXT,
    diagram_image_id UUID,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    is_edited BOOLEAN NOT NULL DEFAULT FALSE,
    edited_at TIMESTAMP WITH TIME ZONE,
    
    -- Foreign Key Constraints
    CONSTRAINT chat_message_chat_id_fkey 
        FOREIGN KEY (chat_id) REFERENCES chat_chat(id) ON DELETE CASCADE,
    CONSTRAINT chat_message_diagram_image_id_fkey 
        FOREIGN KEY (diagram_image_id) REFERENCES chat_diagramimage(id) ON DELETE SET NULL,
    
    -- Check Constraints
    CONSTRAINT chat_message_role_check 
        CHECK (role IN ('user', 'assistant')),
    CONSTRAINT chat_message_type_check 
        CHECK (type IN ('text', 'quiz', 'diagram', 'youtube'))
);

-- Indexes
CREATE INDEX chat_message_chat_id_idx ON chat_message(chat_id);
CREATE INDEX chat_message_created_at_idx ON chat_message(created_at);
CREATE INDEX chat_message_role_idx ON chat_message(role);
CREATE INDEX chat_message_type_idx ON chat_message(type);
CREATE INDEX chat_message_is_edited_idx ON chat_message(is_edited);
CREATE INDEX chat_message_structured_content_gin_idx ON chat_message USING GIN(structured_content);
\end{lstlisting}

\subsubsection{DiagramImage Table Schema}

The diagram storage system uses binary fields for efficient image storage:

\begin{lstlisting}[language=SQL, caption=DiagramImage Table Structure]
CREATE TABLE chat_diagramimage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    chat_id UUID NOT NULL,
    user_id INTEGER NOT NULL,
    image_data BYTEA NOT NULL,
    filename VARCHAR(255) NOT NULL DEFAULT 'diagram.png',
    content_type VARCHAR(50) NOT NULL DEFAULT 'image/png',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- Foreign Key Constraints
    CONSTRAINT chat_diagramimage_chat_id_fkey 
        FOREIGN KEY (chat_id) REFERENCES chat_chat(id) ON DELETE CASCADE,
    CONSTRAINT chat_diagramimage_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users_customuser(id) ON DELETE CASCADE,
    
    -- Check Constraints
    CONSTRAINT chat_diagramimage_content_type_check 
        CHECK (content_type IN ('image/png', 'image/jpeg', 'image/gif', 'image/svg+xml'))
);

-- Indexes
CREATE INDEX chat_diagramimage_chat_id_idx ON chat_diagramimage(chat_id);
CREATE INDEX chat_diagramimage_user_id_idx ON chat_diagramimage(user_id);
CREATE INDEX chat_diagramimage_created_at_idx ON chat_diagramimage(created_at DESC);
CREATE INDEX chat_diagramimage_content_type_idx ON chat_diagramimage(content_type);
\end{lstlisting}

\subsubsection{ChatRAGFile Table Schema}

The RAG file management system includes comprehensive file metadata:

\begin{lstlisting}[language=SQL, caption=ChatRAGFile Table Structure]
CREATE TABLE chat_chatragfile (
    id SERIAL PRIMARY KEY,
    chat_id UUID NOT NULL,
    user_id INTEGER NOT NULL,
    file VARCHAR(100) NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    uploaded_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    
    -- Foreign Key Constraints
    CONSTRAINT chat_chatragfile_chat_id_fkey 
        FOREIGN KEY (chat_id) REFERENCES chat_chat(id) ON DELETE CASCADE,
    CONSTRAINT chat_chatragfile_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users_customuser(id) ON DELETE CASCADE,
    
    -- Unique Constraint to prevent duplicate filenames per chat
    CONSTRAINT chat_chatragfile_unique_chat_filename 
        UNIQUE (chat_id, original_filename)
);

-- Indexes
CREATE INDEX chat_chatragfile_chat_id_idx ON chat_chatragfile(chat_id);
CREATE INDEX chat_chatragfile_user_id_idx ON chat_chatragfile(user_id);
CREATE INDEX chat_chatragfile_uploaded_at_idx ON chat_chatragfile(uploaded_at DESC);
CREATE INDEX chat_chatragfile_original_filename_idx ON chat_chatragfile(original_filename);
\end{lstlisting}

\subsection{Database Schema Visualization}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{images/database_schema_tables.png}
    \caption{Complete Database Schema showing all tables and their structures}
    \label{fig:database_schema}
\end{figure}

\subsection{Advanced Database Features}

\subsubsection{JSON and JSONB Support}

The platform leverages PostgreSQL's native JSON support for flexible data storage:

\begin{lstlisting}[language=SQL, caption=JSON Field Usage Examples]
-- Structured content for YouTube recommendations
SELECT 
    m.id,
    m.content,
    m.structured_content->>'title' as video_title,
    m.structured_content->>'url' as video_url
FROM chat_message m 
WHERE m.type = 'youtube' 
    AND m.structured_content ? 'title';

-- Query for specific video metadata
SELECT *
FROM chat_message 
WHERE structured_content @> '{"type": "video_recommendation"}';
\end{lstlisting}

\subsubsection{Database Constraints and Business Rules}

The schema implements comprehensive data integrity through constraints:

\begin{enumerate}
    \item \textbf{Referential Integrity}: All foreign keys include appropriate CASCADE or SET NULL behaviors
    \item \textbf{Data Validation}: Check constraints ensure valid enum values and ranges
    \item \textbf{Unique Constraints}: Prevent duplicate data (user-interest pairs, chat-filename combinations)
    \item \textbf{Default Values}: Provide sensible defaults for optional fields
    \item \textbf{Timestamp Management}: Automatic tracking of creation and modification times
\end{enumerate}

\subsection{Database Performance Optimization}

\subsubsection{Indexing Strategy}

The database implements a comprehensive indexing strategy:

\begin{lstlisting}[language=SQL, caption=Performance Optimization Indexes]
-- Composite indexes for common query patterns
CREATE INDEX chat_message_chat_created_idx 
    ON chat_message(chat_id, created_at);

CREATE INDEX chat_message_role_type_idx 
    ON chat_message(role, type);

-- Partial indexes for specific use cases
CREATE INDEX chat_message_edited_messages_idx 
    ON chat_message(chat_id, edited_at) 
    WHERE is_edited = TRUE;

-- GIN index for full-text search on content
CREATE INDEX chat_message_content_gin_idx 
    ON chat_message USING GIN(to_tsvector('english', content));

-- Expression indexes for case-insensitive searches
CREATE INDEX users_interest_name_lower_idx 
    ON users_interest(LOWER(name));
\end{lstlisting}

\subsubsection{Query Optimization Patterns}

Common query patterns are optimized through strategic indexing and query design:

\begin{lstlisting}[language=SQL, caption=Optimized Query Examples]
-- Efficient chat history retrieval with message count
SELECT 
    c.id,
    c.title,
    c.updated_at,
    COUNT(m.id) as message_count,
    MAX(m.created_at) as last_message_at
FROM chat_chat c
LEFT JOIN chat_message m ON c.id = m.chat_id
WHERE c.user_id = $1
GROUP BY c.id, c.title, c.updated_at
ORDER BY c.updated_at DESC
LIMIT 20;

-- Efficient user interests with creation date
SELECT 
    i.name,
    ui.created_at
FROM users_interest i
JOIN users_userinterest ui ON i.id = ui.interest_id
WHERE ui.user_id = $1
ORDER BY ui.created_at DESC;

-- RAG file statistics per chat
SELECT 
    c.id as chat_id,
    c.title,
    COUNT(rf.id) as file_count,
    SUM(pg_column_size(rf.file)) as total_file_size
FROM chat_chat c
LEFT JOIN chat_chatragfile rf ON c.id = rf.chat_id
WHERE c.user_id = $1
GROUP BY c.id, c.title;
\end{lstlisting}

\subsection{Data Migration and Versioning}

\subsubsection{Django Migration System}

The platform uses Django's migration system for schema versioning and evolution:

\begin{lstlisting}[language=Python, caption=Example Migration Structure]
# Migration file: 0001_initial.py
class Migration(migrations.Migration):
    initial = True
    dependencies = [('auth', '0012_alter_user_first_name_max_length')]
    
    operations = [
        migrations.CreateModel(
            name='CustomUser',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True)),
                ('password', models.CharField(max_length=128)),
                ('email', models.EmailField(max_length=254, unique=True)),
                # ... additional fields
            ],
            options={'db_table': 'users_customuser'},
        ),
    ]

# Migration file: 0002_add_learning_preferences.py
class Migration(migrations.Migration):
    dependencies = [('users', '0001_initial')]
    
    operations = [
        migrations.AddField(
            model_name='customuser',
            name='learning_style_visual',
            field=models.BooleanField(default=False),
        ),
        # ... additional learning style fields
    ]
\end{lstlisting}

\subsubsection{Database Backup and Recovery Strategy}

Production database management includes automated backup procedures:

\begin{lstlisting}[language=bash, caption=Database Backup Script Example]
#!/bin/bash
# PostgreSQL backup script for Guide Me
BACKUP_DIR="/var/backups/guideme"
DB_NAME="guideme_production"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# Create full database backup
pg_dump -h localhost -U postgres -d $DB_NAME \
    --format=custom \
    --compress=9 \
    --file="$BACKUP_DIR/guideme_backup_$TIMESTAMP.dump"

# Create schema-only backup for development
pg_dump -h localhost -U postgres -d $DB_NAME \
    --schema-only \
    --file="$BACKUP_DIR/guideme_schema_$TIMESTAMP.sql"

# Cleanup old backups (keep 30 days)
find $BACKUP_DIR -name "guideme_backup_*.dump" -mtime +30 -delete
\end{lstlisting}

\subsection{Database Security and Access Control}

\subsubsection{Row Level Security}

The database implements row-level security for multi-tenant data isolation:

\begin{lstlisting}[language=SQL, caption=Row Level Security Implementation]
-- Enable RLS on sensitive tables
ALTER TABLE chat_chat ENABLE ROW LEVEL SECURITY;
ALTER TABLE chat_message ENABLE ROW LEVEL SECURITY;
ALTER TABLE chat_diagramimage ENABLE ROW LEVEL SECURITY;

-- Create policies for user data access
CREATE POLICY chat_user_isolation ON chat_chat
    FOR ALL TO application_user
    USING (user_id = current_setting('app.current_user_id')::INTEGER);

CREATE POLICY message_chat_access ON chat_message
    FOR ALL TO application_user
    USING (
        chat_id IN (
            SELECT id FROM chat_chat 
            WHERE user_id = current_setting('app.current_user_id')::INTEGER
        )
    );
\end{lstlisting}

\subsubsection{Database Connection Security}

Connection security includes SSL/TLS encryption and connection pooling:

\begin{lstlisting}[language=Python, caption=Secure Database Configuration]
# Django database settings with security features
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require',
            'sslcert': '/path/to/client-cert.pem',
            'sslkey': '/path/to/client-key.pem',
            'sslrootcert': '/path/to/ca-cert.pem',
        },
        'CONN_MAX_AGE': 60,  # Connection pooling
        'CONN_HEALTH_CHECKS': True,
    }
}
\end{lstlisting}

\subsection{Database Monitoring and Analytics}

\subsubsection{Performance Monitoring Queries}

Regular monitoring queries help maintain optimal database performance:

\begin{lstlisting}[language=SQL, caption=Database Performance Monitoring]
-- Monitor table sizes and growth
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
    pg_total_relation_size(schemaname||'.'||tablename) as size_bytes
FROM pg_tables 
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Monitor index usage
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- Monitor query performance
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
WHERE query LIKE '%chat_%'
ORDER BY total_time DESC
LIMIT 10;
\end{lstlisting}

\subsection{Indexing and Performance Optimization}

The system implements several performance optimization strategies:

\begin{lstlisting}[language=Python, caption=Model Optimization Examples]
class Chat(models.Model):
    # UUID primary keys for better scalability and security
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    class Meta:
        ordering = ['updated_at']  # Default ordering for efficient queries

class Message(models.Model):
    # Foreign key relationships with proper related_names
    chat = models.ForeignKey(Chat, on_delete=models.CASCADE, related_name='messages')
    
    class Meta:
        ordering = ['created_at']  # Chronological message ordering

class UserInterest(models.Model):
    class Meta:
        unique_together = ('user', 'interest')  # Prevent duplicate entries
        ordering = ['-created_at']
\end{lstlisting}

\section{Security Implementation}

\subsection{Authentication and Authorization}

The platform implements multi-layered security:

\begin{enumerate}
    \item \textbf{Django Authentication}: Built-in user authentication with session management
    \item \textbf{JWT Tokens}: Stateless authentication for API endpoints
    \item \textbf{OAuth Integration}: Google authentication via Django Allauth
    \item \textbf{CSRF Protection}: Cross-Site Request Forgery protection on forms
    \item \textbf{Login Required Decorators}: Endpoint-level access control
\end{enumerate}

\subsection{Data Access Control}

All data access operations include user ownership verification:

\begin{lstlisting}[language=Python, caption=Security Access Patterns]
# Example from ChatView
chat = Chat.objects.get(id=chat_id, user=request.user)

# Example from RAG file operations
rag_file = ChatRAGFile.objects.get(id=file_id, chat=chat, user=request.user)

# Example from message editing
if message_to_edit.chat.user != request.user:
    return JsonResponse({'error': 'User not authorized'}, status=403)
\end{lstlisting}

\section{Performance and Scalability Considerations}

\subsection{Asynchronous Processing}

The system leverages Django's async capabilities for improved performance:

\begin{lstlisting}[language=Python, caption=Async Implementation Example]
class ChatStreamView(View):
    async def post(self, request, chat_id):
        user = await request.auser()
        chat = await sync_to_async(get_object_or_404)(Chat, id=chat_id, user=user)
        
        # Async database operations
        await sync_to_async(close_old_connections)()
        await sync_to_async(Message.objects.create)(chat=chat, role='user', content=content)
\end{lstlisting}

\subsection{Streaming Response Optimization}

The streaming system implements buffering strategies for optimal client experience:

\begin{lstlisting}[language=Python, caption=Streaming Buffer Management]
frontend_buffer = ""
BUFFER_LENGTH_THRESHOLD_CHARS = 50

for chunk in stream:
    content = getattr(chunk.choices[0].delta, "content", None)
    if content:
        frontend_buffer += content
        
        if ("\n" in frontend_buffer) or (len(frontend_buffer) >= BUFFER_LENGTH_THRESHOLD_CHARS):
            yield f"data: {json.dumps({'type': 'content', 'content': frontend_buffer})}\n\n"
            frontend_buffer = ""
\end{lstlisting}

\subsection{Database Query Optimization}

Strategic use of select\_related and prefetch\_related for reducing database queries:

\begin{lstlisting}[language=Python, caption=Query Optimization Examples]
# Efficient chat loading with messages
db_messages = chat.messages.all().order_by('created_at')

# Efficient user interest loading
user_interests = request.user.interests.all()

# RAG files with proper ordering
rag_files = chat.rag_files.all().order_by('-uploaded_at')
\end{lstlisting}

\section{Error Handling and Logging}

\subsection{Comprehensive Logging Strategy}

The system implements detailed logging across all major operations:

\begin{lstlisting}[language=Python, caption=Logging Implementation]
import logging
logger = logging.getLogger(__name__)

# Example logging patterns
logger.info(f"ChatStreamView.post called for chat_id={chat_id} by user {user.id}")
logger.error(f"Exception in ChatStreamView.post: {str(e)}", exc_info=True)
logger.warning(f"File {filename} was truncated. Original: {original_count} chars")
\end{lstlisting}

\subsection{API Error Handling}

Structured error responses with appropriate HTTP status codes:

\begin{lstlisting}[language=Python, caption=Error Response Patterns]
# Validation errors
if not new_content:
    return JsonResponse({'error': 'New content cannot be empty.'}, status=400)

# Authorization errors
if message_to_edit.role != 'user':
    return JsonResponse({'error': 'Only user messages can be edited.'}, status=403)

# Not found errors
except Chat.DoesNotExist:
    return JsonResponse({'error': 'Chat not found'}, status=404)

# Server errors
except Exception as e:
    logger.error(f"Error: {e}", exc_info=True)
    return JsonResponse({'error': 'Internal server error'}, status=500)
\end{lstlisting}

\section{Integration Points and External Services}

\subsection{AI Service Integration}

The platform integrates with multiple AI services:

\begin{enumerate}
    \item \textbf{Groq API}: Primary LLM for conversational AI with streaming support
    \item \textbf{Google Gemini}: Specialized tasks like flashcard generation
    \item \textbf{Custom RAG Service}: Document processing and retrieval augmentation
    \item \textbf{YouTube Agent}: Video content recommendation system
\end{enumerate}

\subsection{File Storage Integration}

Django's file storage system with configurable backends:

\begin{lstlisting}[language=Python, caption=File Storage Configuration]
# RAG file upload path generation
def rag_file_upload_path(instance, filename):
    return f'rag_files/user_{instance.user.id}/chat_{instance.chat.id}/{filename}'

# Binary field storage for diagrams
class DiagramImage(models.Model):
    image_data = models.BinaryField()
    content_type = models.CharField(max_length=50, default="image/png")
\end{lstlisting}

\section{Testing and Development Considerations}

\subsection{Development Environment Setup}

The project structure supports multiple environment configurations:

\begin{itemize}
    \item \textbf{DEBUG Mode}: Comprehensive error reporting and static file serving
    \item \textbf{Media Handling}: Configurable MEDIA\_ROOT and MEDIA\_URL settings
    \item \textbf{Database Flexibility}: Support for multiple database backends
    \item \textbf{Environment Variables}: Secure API key and configuration management
\end{itemize}

\subsection{Code Quality and Maintenance}

\begin{enumerate}
    \item \textbf{Type Hints}: Strategic use of Python type hints for better code documentation
    \item \textbf{Docstrings}: Comprehensive function and class documentation
    \item \textbf{Error Handling}: Defensive programming with comprehensive exception handling
    \item \textbf{Code Organization}: Logical separation of concerns across Django apps
\end{enumerate}

\section{Future Scalability and Enhancement Opportunities}

\subsection{Performance Optimization Opportunities}

\begin{itemize}
    \item \textbf{Caching Layer}: Redis implementation for frequently accessed data
    \item \textbf{Database Optimization}: Query optimization and indexing strategies
    \item \textbf{CDN Integration}: Static and media file delivery optimization
    \item \textbf{Load Balancing}: Horizontal scaling preparation
\end{itemize}

\subsection{Feature Enhancement Possibilities}

\begin{itemize}
    \item \textbf{Real-time Collaboration}: WebSocket integration for multi-user chats
    \item \textbf{Advanced Analytics}: User behavior tracking and learning analytics
    \item \textbf{Mobile API}: RESTful API expansion for mobile applications
    \item \textbf{Advanced RAG}: Vector database integration for improved document search
\end{itemize}

\section{Conclusion}

The Guide Me backend represents a sophisticated, production-ready implementation of an AI-powered educational platform. The architecture successfully balances feature richness with maintainability, providing a solid foundation for an intelligent tutoring system.

Key architectural strengths include:

\begin{itemize}
    \item \textbf{Modular Design}: Clean separation of concerns across Django applications
    \item \textbf{Scalable Data Models}: Flexible database design supporting multiple content types
    \item \textbf{Real-time Capabilities}: Efficient streaming responses with proper error handling
    \item \textbf{Security Focus}: Comprehensive authentication and authorization implementation
    \item \textbf{Integration Flexibility}: Extensible architecture supporting multiple AI services
\end{itemize}

The codebase demonstrates enterprise-level Django development practices, with particular attention to asynchronous processing, error handling, and user experience optimization. The platform is well-positioned for continued development and scaling to serve larger user bases while maintaining performance and reliability.

This documentation serves as a comprehensive reference for developers working with the Guide Me backend, providing both high-level architectural understanding and detailed implementation guidance for all major system components.

\end{document}
